1.
“typeof和instanceof的区别：
typeof可以判断所有变量的类型，判断对象时只能返回Object。instanceof可以对不同的对象实例进行判断。”
  typeof判断所有变量的类型，返回值有number，boolean，string，function，object，undefined

2.
CSS自定义属性 动态变量 替代预处理器
 https://segmentfault.com/a/1190000015948538

3. flex可以做的事
   3.1双飞翼布局 左右固定中间自适应
父元素设置display：flex 左右固定宽高
	子元素设置 flex: 1;             === flex: 1 1 auto;   
 	
第一个参数表示: flex-grow 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大
第二个参数表示: flex-shrink 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小
第三个参数表示: flex-basis给上面两个属性分配多余空间之前, 计算项目是否有多余空间, 默认值为 auto, 即项目本身的大小
   3.2  垂直居中 
	父元素display：flex
	子元素 justify-content：center；align-items:center
     等效的有父元素display：table-cell;vertical-align：middle;text-align:center 子元素display：inline-block 等同img标签

4. 闭包的理解
	闭包就是能够读取其他函数内部变量的函数
	js并不是为了创造闭包而创造，完全只是因为js允许函数嵌套，还能return返回子函数，以及js特有的事件循环机制，导致这些子函数不是立即调用，让父函数不敢注销自己作用域中的数据，才会产生所谓闭包。
也正因为这个闭包这个特性，闭包函数可以让父函数的数据一直驻留在内存中保存，从而这也是后来js模块化的基础。

5. 利用bfc块级格式化上下文, 实现两侧固定中间自适应
左右固定宽高然后浮动，中间overflow：hidden 
！！！且left和right必须放在center前面

6.内联元素与块级元素的边距问题
块级元素垂直方向margin折叠问题  两个相邻取较大值；水平方向相邻边距正常相加
内联元素可以设置左右padding 垂直padding无效，以及设置 width 和 height 属性的值是无效的

7. 文本的居中
 水平居中 div中text-align：center
 垂直居中 div的height值与line-height相同

8. CSS3中em和rem单位
em为相对父元素font-size大小，rem（root）为相对html标签font-size大小

9.向上的箭头
 .up{
 width:0px;
 height:0;
 border-width:0 28px 28px;
 border-style:solid;
 border-color:transparent transparent red
 }


10.     rem适配方法中浏览器最小字体兼容处理：
	html{font-size:625%} body{font-size:0.16rem}
再使用媒体查询media screen(){}兼容每个屏幕的根font-size
	原因：若设为62.5% ，font-size:62.5%刚好是10像素 chrome在字体小于12px时都当12px 处理rem的根字体大小参照实际则变为75%（12px）
	即设置1rem为100px条件下，最小字体16px
定义一个设计稿能整除的系数，设计稿尺寸除以该系数得到相对值rem单位，动态获得屏幕宽度来设置html.style.fontSize：当前屏幕宽度/该系数同为一单位的rem 此时使用设计稿换算后的rem单位即可
	图片适配情况：
	如果是Img标签， 可以设置宽度为切出的图片尺寸，换算成rem，
是background-img，用background-size属性，设置设计图尺寸宽高，换算成rem进行图片的缩放适配

11.     浮动的一些问题
	浮动定位也是脱离文档流，不占据空间，停留在包含元素边框或浮动元素边框
	浮动影响：父元素高度无法被撑开，影响父元素统计结构
	 	同级非浮动（内联）元素会紧随
		 浮动相邻元素同样需要浮动
	1.父元素影响解决方案：
	.clearfix:after{content: ".";display: block;height: 0;clear: both;visibility: hidden;}
	.clearfix{ zoom:1;display: inline-block;} /* for IE/Mac */
	2.浮动元素同级影响解决方案：
	放置一个空div 设置clear:both;
	3.给父级元素设置overflow：hidden；或overflow：auto；本质是构建一个BFC
   
12.   align-content与align-items区别：
	content只适用于多行flex容器（设置在父元素上），当容器交叉轴存在多余空间时，所有子项作为一个整体对竖直方向的对齐设置
	items应用于所有flex容器，设置flex子项在每一个flex行的交叉轴竖直对齐方式

    选择父元素下对应的子元素，一个是:nth-child 另一个是:nth-of-type。区别是：
	ele:nth-of-type(n)是指父元素下第n个ele元素， 
	ele:nth-child(n)是指父元素下第n个元素且这个元素为ele，若不是，则选择失败
ex：  <ul class="demo">
    <p>zero</p>
    <li>one</li>   .demo li:nth-child(2)      <li>标签的父元素的第二个子元素
    <li>two</li>   .demo li:nth-of-type(2)  <li>标签的父元素的第二个<li>子元素
  </ul>
ps. 	不指定标签类型时，:nth-type-of(2)会选中所有类型标签的第二个。


13.    BFC:块级格式化上下文
	它规定了内部的Block-level-box如何布局，以及对该区域外部毫不相干
	布局规则：1.内部的BOX会在垂直方向，一个接一个地放置
		2.Box垂直方向的距离有margin规定，属于同一个BFC的两个相邻Box的margin会发生重叠（margin collapse）
 		3.每个元素的margin box左边，与包含块border box的左边接触（同方向接触的格式化）。即使存在浮动也如此
		4.BFC区域不会和Float Box重叠
		5.BFC就是一个隔离的独立容器，容器里面的子元素不会影响到外面
		6.浮动元素也参与计算BFC高度
	生成BFC的元素：
		根元素、float不为none、position为absolute或fixed、display为inline-block，table-cell，table-caption,flex，inline-flex、overflow非默认即不为visible


14.   IE11 / Safari 9 support with polyfill
15. 大屏幕适配思路：
	1.初始化时候获得大屏幕比例
	2.得到比例设置给CSS的scale变量
	3.监听浏览器窗口大小，将新的比例赋给scale变量
	ps. vue中实现：
<div ref="scaleBox">
mounted(){this.setScale();window.addEventListener("resize",this.setScale)}

getScale(){const{width,height}=this; let ww= window,innerWidth/width;let wh=window.innerHeight/height; return ww<wh?ww:wh;}

setScale(){this.scale= this.getScale();this.$refs.scaleBox.style.setProperty("--scale",this.scale);}   //

#scaleBox{--scale:1;} .scaleBox{transform:scale(var(--scale));}
	ps.
	CSS中变量定义: --XXX:XXX;
	CSS中变量使用: var(--XXX)
	vue中的dom应该用ref来定义, 然后在在函数中用this.$refs.XXX
	来调用,这里的ref相当于id
	缩放后的垂直水平集中CSS：{
	transform: scale(var(--scale)) translate(-50%, -50%);
	position: absolute;
	left: 50%;
	top: 50%;
	}
最后使用节流（throttle）函数控制触发 限定时间执行一次
   16.节流与防抖（debounce）函数
    防抖函数为频繁触发的函数，在规定时间内，只让最后一次生效 应用场景如调用接口请求频繁触发则执行最后一次结果
    节流函数为触发函数的限定时间执行一次，应用场景一般是onrize，onscroll等这些频繁触发的函数
	//函数节流器   //定时响应  高频操作限定时间内首次执行
//只有大于设定的执行周期才会执行第二次  
function throttle(fn, delay) {
    //记录上次函数触发的时间
    let lastTime = 0;
    return function () {
        //记录当前函数触发的时间
        let nowTime = Date.now();
        if (nowTime - lastTime > delay) {
            fn();
            //同步时间
            lastTime = nowTime
            //可以让局部变量不被重置，通常来说 这是需要一个全局变量的。但是通过一个闭包也能完成。
        }
    }
}
	//函数防抖器   多次事件一次响应  高频操作限定时间内最后一次执行
//一个需要频繁触发的函数，在规定时间内，只让最后一次生效，前面的不生效 (再次被触发，则重新计算延迟时间)
function debounce(fn, delay) {
    let delays = delay || 500;
    //清除上一次的延时器
    let timer = null
    clearInterval(timer)
    timer = setTimeout(() => {
        fn();
    }, delays);
}
   17.